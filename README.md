# Введение в информационные технологии
### Часть 1. Базовые конструкции языка С++

#### 1. Структура программы на С++, функция main(…), директивы препроцессора и комментарии. Многофайловые приложения. Заголовочные файлы. Недопущение повторного включения.

**Определение**: Программа на С++ состоит из исходных файлов, содержащих функции, классы, переменные и другие элементы. Основной точкой входа является функция `main()`. Программа обрабатывается препроцессором, компилятором, компоновщиком и выполняется.

- **Функция main()**: Точка входа программы. Возвращает `int` (код завершения: 0 — успех, ненулевое значение — ошибка). Может принимать аргументы для обработки параметров командной строки.
  ```cpp
  int main() {
      return 0; // Успешное завершение
  }
  int main(int argc, char* argv[]) { // argc — кол-во аргументов, argv — массив строк
      for (int i = 0; i < argc; ++i) {
          std::cout << argv[i] << std::endl;
      }
      return 0;
  }
  ```

- **Директивы препроцессора**: Инструкции, начинающиеся с `#`, выполняются до компиляции. Примеры:
  - `#include <iostream>`: Подключает библиотеку.
  - `#define PI 3.14`: Определяет макрос.
  - `#ifdef DEBUG ... #endif`: Условная компиляция.
  ```cpp
  #include <iostream>
  #define SQUARE(x) ((x) * (x))
  int main() {
      std::cout << SQUARE(5) << std::endl; // 25
      return 0;
  }
  ```

- **Комментарии**: Пояснения в коде, игнорируются компилятором.
  - Однострочные: `// Комментарий`.
  - Многострочные: `/* Комментарий */`.
  ```cpp
  // Это однострочный комментарий
  /* Это
     многострочный
     комментарий */
  ```

- **Многофайловые приложения**: Программа делится на файлы `.cpp` (реализация) и `.h` (заголовки). Заголовки содержат объявления функций, классов, констант.
  - Пример структуры:
    - `main.cpp`: Содержит `main()`.
    - `utils.h`: Объявления функций.
    - `utils.cpp`: Реализация функций.
  ```cpp
  // utils.h
  #ifndef UTILS_H
  #define UTILS_H
  int add(int a, int b);
  #endif

  // utils.cpp
  #include "utils.h"
  int add(int a, int b) { return a + b; }

  // main.cpp
  #include <iostream>
  #include "utils.h"
  int main() {
      std::cout << add(2, 3) << std::endl; // 5
      return 0;
  }
  ```

- **Недопущение повторного включения**: Защищает от многократного включения заголовочного файла.
  - Используется `#ifndef`, `#define`, `#endif` или `#pragma once`.
  ```cpp
  // utils.h с защитой
  #ifndef UTILS_H
  #define UTILS_H
  // Код заголовка
  #endif

  // Или с #pragma once
  #pragma once
  // Код заголовка
  ```

#### 2. Область видимости и время жизни переменных. Классификатор extern. Области памяти программы.

**Определение**: Область видимости определяет, где переменная доступна. Время жизни — период существования переменной в памяти.

- **Область видимости**:
  - **Локальная**: Внутри блока `{}` (например, в функции).
  - **Глобальная**: Вне всех функций, доступна во всем файле.
  - **Файловая**: С `static` в файле, видима только в этом файле.
  - **Пространство имен**: Внутри `namespace`.
  ```cpp
  int global = 10; // Глобальная
  namespace ns {
      int ns_var = 20; // Пространство имен
  }
  static int file_var = 30; // Файловая
  int main() {
      int local = 40; // Локальная
      std::cout << global << " " << ns::ns_var << " " << file_var << " " << local << std::endl;
      return 0;
  }
  ```

- **Время жизни**:
  - **Автоматические**: Существуют в блоке, уничтожаются при выходе.
  - **Статические**: Существуют весь период работы программы.
  - **Динамические**: Создаются с `new`, уничтожаются с `delete`.
  ```cpp
  void func() {
      static int count = 0; // Статическая, сохраняет значение
      ++count;
      std::cout << count << std::endl;
  }
  int main() {
      func(); // 1
      func(); // 2
      int* ptr = new int(5); // Динамическая
      delete ptr; // Освобождение
      return 0;
  }
  ```

- **Классификатор extern**: Объявляет переменную, определенную в другом файле, без выделения памяти.
  ```cpp
  // file1.cpp
  int shared = 100;

  // file2.cpp
  extern int shared; // Объявление
  int main() {
      std::cout << shared << std::endl; // 100
      return 0;
  }
  ```

- **Области памяти**:
  - **Стек**: Локальные переменные, параметры функций, быстрый доступ, ограниченный размер.
  - **Куча**: Динамические объекты, управляется вручную.
  - **Сегмент данных**: Глобальные и статические переменные (инициализированные и неинициализированные).
  - **Сегмент кода**: Машинный код программы.
  ```cpp
  int global = 1; // Сегмент данных
  int main() {
      int local = 2; // Стек
      int* heap = new int(3); // Куча
      delete heap;
      return 0;
  }
  ```

#### 3. Приведение простых типов. Размер типов. Суффиксы литералов. Литералы интегральных типов. Функция sizeof().

**Определение**: Приведение типов изменяет интерпретацию данных. Размер типов зависит от платформы. Литералы задают значения с явным типом.

- **Приведение типов**:
  - **Явное**: Используется `(тип)` или `static_cast<тип>`.
  - **Неявное**: Выполняется автоматически при совместимых типах.
  ```cpp
  int main() {
      double d = 3.14;
      int i = (int)d; // Явное, i = 3
      int j = d; // Неявное, j = 3
      std::cout << i << " " << j << std::endl;
      return 0;
  }
  ```

- **Размер типов**: Зависит от архитектуры (обычно 32/64 бит).
  - `char`: 1 байт.
  - `int`: 4 байта.
  - `double`: 8 байт.
  - `long long`: 8 байт.
  ```cpp
  int main() {
      std::cout << sizeof(char) << " " << sizeof(int) << " " << sizeof(double) << std::endl;
      return 0;
  }
  ```

- **Суффиксы литералов**: Указывают тип константы.
  - `u`: `unsigned int` (например, `123u`).
  - `l`: `long` (например, `123l`).
  - `f`: `float` (например, `3.14f`).
  ```cpp
  int main() {
      unsigned int u = 123u;
      long l = 123l;
      float f = 3.14f;
      std::cout << u << " " << l << " " << f << std::endl;
      return 0;
  }
  ```

- **Литералы интегральных типов**:
  - Десятичные: `123`.
  - Восьмеричные: `0123` (начинаются с 0).
  - Шестнадцатеричные: `0x7B` (начинаются с `0x`).
  - Двоичные (C++14): `0b1111011` (начинаются с `0b`).
  ```cpp
  int main() {
      int dec = 123;
      int oct = 0123; // 83 в десятичной
      int hex = 0x7B; // 123 в десятичной
      int bin = 0b1111011; // 123 в десятичной
      std::cout << dec << " " << oct << " " << hex << " " << bin << std::endl;
      return 0;
  }
  ```

- **sizeof()**: Возвращает размер типа или объекта в байтах.
  ```cpp
  int main() {
      int x = 5;
      std::cout << sizeof(x) << " " << sizeof(int) << std::endl; // 4 4
      return 0;
  }
  ```

#### 4. Объявление нового типа. Структуры. Особенности хранения в памяти.

**Определение**: Новый тип создается для удобства работы с данными. Структуры объединяют данные в единый объект.

- **Объявление типа**:
  - `typedef`: Создает псевдоним типа.
  - `using`: Современный способ (C++11).
  ```cpp
  typedef unsigned int uint;
  using uint = unsigned int;
  int main() {
      uint x = 5;
      std::cout << x << std::endl;
      return 0;
  }
  ```

- **Структуры**: Определяются с `struct`, содержат поля (переменные).
  ```cpp
  struct Point {
      int x, y;
  };
  int main() {
      Point p = {1, 2};
      std::cout << p.x << " " << p.y << std::endl;
      return 0;
  }
  ```

- **Хранение в памяти**:
  - Поля структуры располагаются последовательно.
  - **Выравнивание памяти (padding)**: Компилятор добавляет "пустые" байты для оптимизации доступа.
  ```cpp
  struct Example {
      char c; // 1 байт
      int i;  // 4 байта, но из-за выравнивания добавляется 3 байта padding
  };
  int main() {
      std::cout << sizeof(Example) << std::endl; // 8 (1 + 3 + 4)
      return 0;
  }
  ```

#### 5. Базовые типы данных. Объявление переменных. Классификатор const. Операции.

**Определение**: Базовые типы — фундаментальные типы данных для хранения значений. Переменные объявляются с указанием типа. Операции выполняют вычисления.

- **Базовые типы**:
  - **Целые**: `int`, `short`, `long`, `long long`, `unsigned` модификаторы.
  - **Вещественные**: `float`, `double`, `long double`.
  - **Символьные**: `char`, `wchar_t`.
  - **Логический**: `bool`.
  ```cpp
  int main() {
      int i = 5;
      double d = 3.14;
      char c = 'A';
      bool b = true;
      std::cout << i << " " << d << " " << c << " " << b << std::endl;
      return 0;
  }
  ```

- **Объявление переменных**: `тип имя = значение;`.
  ```cpp
  int x = 10;
  double y = 2.5;
  ```

- **const**: Запрещает изменение переменной.
  ```cpp
  const int MAX = 100;
  // MAX = 200; // Ошибка
  ```

- **Операции**:
  - **Арифметические**: `+`, `-`, `*`, `/`, `%`.
  - **Логические**: `&&`, `||`, `!`.
  - **Битовые**: `&`, `|`, `^`, `~`, `<<`, `>>`.
  ```cpp
  int main() {
      int a = 5, b = 3;
      std::cout << a + b << " " << (a && b) << " " << (a & b) << std::endl; // 8 1 1
      return 0;
  }
  ```

#### 6. Операторы условного перехода. Перечислимый тип.

**Определение**: Условные операторы управляют выполнением кода на основе условий. Перечислимый тип задает набор именованных констант.

- **Условные операторы**:
  - `if`: Проверяет условие.
  - `switch`: Выбирает ветку по значению.
  - Тернарный оператор: `условие ? выражение1 : выражение2`.
  ```cpp
  int main() {
      int x = 5;
      if (x > 0) {
          std::cout << "Positive" << std::endl;
      } else {
          std::cout << "Non-positive" << std::endl;
      }
      switch (x) {
          case 5: std::cout << "Five" << std::endl; break;
          default: std::cout << "Other" << std::endl;
      }
      std::cout << (x > 0 ? "Positive" : "Non-positive") << std::endl;
      return 0;
  }
  ```

- **Перечислимый тип**:
  - `enum`: Простой перечислитель.
  - `enum class`: Типобезопасный (C++11).
  ```cpp
  enum Color { RED, GREEN, BLUE };
  enum class Status : int { OK = 1, ERROR = -1 };
  int main() {
      Color c = RED;
      Status s = Status::OK;
      std::cout << c << " " << static_cast<int>(s) << std::endl; // 0 1
      return 0;
  }
  ```

#### 7. Организация циклов.

**Определение**: Циклы повторяют выполнение кода до выполнения условия.

- **Типы циклов**:
  - `for`: Для известного числа итераций.
  - `while`: Пока условие истинно.
  - `do-while`: Выполняется хотя бы раз.
  ```cpp
  int main() {
      for (int i = 0; i < 3; ++i) {
          std::cout << i << " ";
      } // 0 1 2
      int j = 0;
      while (j < 3) {
          std::cout << j << " ";
          ++j;
      } // 0 1 2
      int k = 0;
      do {
          std::cout << k << " ";
          ++k;
      } while (k < 3); // 0 1 2
      std::cout << std::endl;
      return 0;
  }
  ```

- **Управление**:
  - `break`: Выход из цикла.
  - `continue`: Переход к следующей итерации.
  ```cpp
  int main() {
      for (int i = 0; i < 5; ++i) {
          if (i == 2) continue;
          if (i == 4) break;
          std::cout << i << " ";
      } // 0 1 3
      std::cout << std::endl;
      return 0;
  }
  ```

#### 8. Стек и куча. Динамическая память. Операторы «.» и «->».

**Определение**: Стек и куча — области памяти для хранения данных. Динамическая память управляется вручную.

- **Стек**: Хранит локальные переменные, параметры функций. Быстрый, ограниченный размер.
- **Куча**: Хранит динамически выделенные объекты. Медленнее, больший объем.
  ```cpp
  int main() {
      int stack_var = 5; // Стек
      int* heap_var = new int(10); // Куча
      std::cout << stack_var << " " << *heap_var << std::endl;
      delete heap_var; // Освобождение
      return 0;
  }
  ```

- **Операторы**:
  - `.`: Доступ к членам объекта.
  - `->`: Доступ к членам через указатель.
  ```cpp
  struct Point {
      int x, y;
  };
  int main() {
      Point p = {1, 2};
      Point* ptr = &p;
      std::cout << p.x << " " << ptr->x << std::endl; // 1 1
      return 0;
  }
  ```

#### 9. Указатели и ссылочные переменные. Особенности работы. Классификатор const.

**Определение**: Указатели хранят адрес памяти, ссылки — псевдонимы переменных.

- **Указатели**:
  - Хранят адрес: `тип* имя = &переменная;`.
  - Разыменование: `*указатель`.
  - Арифметика: `ptr + n` смещает на `n * sizeof(тип)` байт.
  ```cpp
  int main() {
      int x = 5;
      int* ptr = &x;
      *ptr = 10;
      std::cout << x << " " << *ptr << std::endl; // 10 10
      return 0;
  }
  ```

- **Ссылки**:
  - Псевдоним: `тип& имя = переменная;`.
  - Нельзя переназначить, не занимают отдельной памяти.
  ```cpp
  int main() {
      int x = 5;
      int& ref = x;
      ref = 10;
      std::cout << x << " " << ref << std::endl; // 10 10
      return 0;
  }
  ```

- **const**:
  - `const int*`: Указатель на константу.
  - `int* const`: Константный указатель.
  - `const int&`: Ссылка на константу.
  ```cpp
  int main() {
      const int x = 5;
      const int* ptr = &x; // Указатель на константу
      // *ptr = 10; // Ошибка
      int y = 10;
      int* const ptr2 = &y; // Константный указатель
      *ptr2 = 15; // OK
      // ptr2 = &x; // Ошибка
      const int& ref = x; // Ссылка на константу
      std::cout << *ptr << " " << *ptr2 << " " << ref << std::endl;
      return 0;
  }
  ```

#### 10. Статические массивы. Объявление, инициализация, хранение, обращение, передача. Две схемы хранения матриц.

**Определение**: Статические массивы — фиксированные по размеру наборы данных одного типа.

- **Объявление и инициализация**:
  ```cpp
  int main() {
      int arr[5] = {1, 2, 3, 4, 5};
      int arr2[5] = {0}; // Все элементы 0
      std::cout << arr[0] << " " << arr2[0] << std::endl;
      return 0;
  }
  ```

- **Хранение**: Непрерывный участок памяти.
- **Обращение**: Через индекс `arr[i]`.
- **Передача**: Массив преобразуется в указатель на первый элемент.
  ```cpp
  void printArray(int arr[], int size) {
      for (int i = 0; i < size; ++i) {
          std::cout << arr[i] << " ";
      }
  }
  int main() {
      int arr[3] = {1, 2, 3};
      printArray(arr, 3); // 1 2 3
      std::cout << std::endl;
      return 0;
  }
  ```

- **Схемы хранения матриц в динамической памяти**:
  1. **Массив указателей**:
     ```cpp
     int** matrix = new int*[rows];
     for (int i = 0; i < rows; ++i) {
         matrix[i] = new int[cols];
     }
     // Освобождение
     for (int i = 0; i < rows; ++i) {
         delete[] matrix[i];
     }
     delete[] matrix;
     ```
  2. **Непрерывный массив**:
     ```cpp
     int* matrix = new int[rows * cols];
     // Доступ: matrix[i * cols + j]
     delete[] matrix;
     ```

#### 11. Адресная арифметика. Приведение типов указателей. Тип void*.

**Определение**: Адресная арифметика позволяет манипулировать адресами памяти. `void*` — универсальный указатель.

- **Адресная арифметика**: `ptr + n` смещает указатель на `n * sizeof(тип)` байт.
  ```cpp
  int main() {
      int arr[3] = {1, 2, 3};
      int* ptr = arr;
      std::cout << *(ptr + 1) << std::endl; // 2
      return 0;
  }
  ```

- **Приведение типов**:
  ```cpp
  int main() {
      int x = 5;
      void* vptr = &x;
      int* iptr = static_cast<int*>(vptr);
      std::cout << *iptr << std::endl; // 5
      return 0;
  }
  ```

- **void***: Хранит адрес без типа, требует приведения перед использованием.
  ```cpp
  int main() {
      int x = 5;
      void* ptr = &x;
      // std::cout << *ptr; // Ошибка
      std::cout << *static_cast<int*>(ptr) << std::endl; // 5
      return 0;
  }
  ```

#### 12. Статические и динамические массивы. Строки в стиле С.

**Определение**: Массивы бывают фиксированного (статические) и изменяемого (динамические) размера. Строки в стиле С — массивы `char` с завершающим `\0`.

- **Статические массивы**:
  ```cpp
  char str[10] = "Hello";
  ```

- **Динамические массивы**:
  ```cpp
  char* str = new char[10];
  strcpy(str, "Hello");
  delete[] str;
  ```

- **Строки C-style**:
  ```cpp
  int main() {
      char str[] = "Hello";
      std::cout << str << " " << strlen(str) << std::endl; // Hello 5
      return 0;
  }
  ```

- **sizeof()**: Для массива — размер массива, для указателя — размер указателя.
  ```cpp
  int main() {
      char str[] = "Hello";
      char* ptr = str;
      std::cout << sizeof(str) << " " << sizeof(ptr) << std::endl; // 6 8
      return 0;
  }
  ```

#### 13. Прототипы и описание функций. Рекурсия. Стек вызова. Имя функции как указатель.

**Определение**: Функции выполняют задачи, имеют прототипы (объявления) и определения. Рекурсия — вызов функции из самой себя.

- **Прототип и определение**:
  ```cpp
  int add(int a, int b); // Прототип
  int main() {
      std::cout << add(2, 3) << std::endl; // 5
      return 0;
  }
  int add(int a, int b) { // Определение
      return a + b;
  }
  ```

- **Рекурсия**:
  ```cpp
  int factorial(int n) {
      if (n <= 1) return 1;
      return n * factorial(n - 1);
  }
  int main() {
      std::cout << factorial(5) << std::endl; // 120
      return 0;
  }
  ```

- **Стек вызова**: Хранит кадры активации (аргументы, локальные переменные, адрес возврата).
- **Имя функции**: Указатель на функцию.
  ```cpp
  int main() {
      int (*func)(int, int) = add;
      std::cout << func(2, 3) << std::endl; // 5
      return 0;
  }
  ```

#### 14. Способы передачи аргументов. rvalue и lvalue. Ссылки. Продление жизни.

**Определение**: Аргументы передаются по значению, указателю или ссылке. `lvalue` — объект с адресом, `rvalue` — временный объект.

- **Передача**:
  - **По значению**: Копия.
  - **По указателю**: Адрес.
  - **По ссылке**: Псевдоним.
  ```cpp
  void byValue(int x) { x = 10; }
  void byPointer(int* x) { *x = 10; }
  void byReference(int& x) { x = 10; }
  int main() {
      int a = 5, b = 5, c = 5;
      byValue(a);
      byPointer(&b);
      byReference(c);
      std::cout << a << " " << b << " " << c << std::endl; // 5 10 10
      return 0;
  }
  ```

- **lvalue и rvalue**:
  - `lvalue`: Переменная (`int x;`).
  - `rvalue`: Временный объект (`5`, `func()`).
  ```cpp
  int main() {
      int x = 5; // x — lvalue, 5 — rvalue
      x = 10; // OK
      // 5 = 10; // Ошибка
      return 0;
  }
  ```

- **Ссылки**:
  - Левосторонние (`&`) — для `lvalue`.
  - Правосторонние (`&&`) — для `rvalue`.
  - `const T&` продлевает жизнь `rvalue`.
  ```cpp
  int main() {
      const int& ref = 5; // Продление жизни rvalue
      std::cout << ref << std::endl; // 5
      return 0;
  }
  ```

#### 15. Функции с аргументами по умолчанию.

**Определение**: Аргументы по умолчанию задаются в протоколе функции.

- **Пример**:
  ```cpp
  void print(int x, int y = 0) {
      std::cout << x << " " << y << std::endl;
  }
  int main() {
      print(5); // 5 0
      print(5, 10); // 5 10
      return 0;
  }
  ```

- **Ограничения**:
  - Аргументы по умолчанию задаются справа налево.
  - Нельзя задавать в определении и прототипе одновременно.
  ```cpp
    // utils.h
    void func(int x, int y = 0;);
    // utils.cpp
   void func(int x, int y) { … } // Ошибка, если y имеет default в определении```


#### 16. Перегрузка функций.

**Определение**: Функции с одинаковыми именами, но разными параметрами.

- **Пример**:
  ```cpp
  int add(int a, int b) { return a + b; }
  double add(double a, double b) { return a + b; }
  int main() {
      std::cout << add(2, 3) << " " << add(2.5, 3.5) << std::endl; // 5 6
      return 0;
  }
  ```

- **Ограничения**:
  - Нельзя различать по возвращаемому типу.
  - Нельзя перегружать по `const` для аргументов по значению.

#### 17. Автоматический вывод типа: auto, decltype.

**Определение**: `auto` и `decltype` упрощают работу с типами.

- **auto**: Компилятор выводит тип.
- **decltype**: Определяет тип выражения.
  ```cpp
  int main() {
      auto x = 5; // int
      auto y = 3.14; // double
      decltype(x) z = 10; // int
      std::cout << x << " " << z << std::endl; // 5 10
      return 0;
  }
  ```

- **Синонимы типов**:
  ```cpp
  using uint = unsigned int;
  ```

#### 18. Обработка ошибок.

**Определение**: Ошибки обрабатываются кодами или исключениями.

- **Коды ошибок**:
  ```cpp
  int divide(int a, int b, int* result) {
      if (b == 0) return -1;
      *result = a / b;
      return 0;
  }
  int main() {
      int res;
      if (divide(10, 2, &res) == 0) {
          std::cout << res << std::endl; // 5
      } else {
          std::cerr << "Ошибка" << std::endl;
      }
      return 0;
  }
  ```

- **Исключения**:
  ```cpp
  int main() {
      try {
          throw std::runtime_error("Ошибка");
      } catch (const std::exception& e) {
          std::cerr << e.what() << std::endl;
      }
      return 0;
  }
  ```

---

